# generated by datamodel-codegen:
#   filename:  grist-openapi.yml
#   timestamp: 2024-09-20T08:21:27+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, BaseModel, Field, RootModel
from typing_extensions import Annotated


class WebhookRequiredFields(BaseModel):
    unsubscribeKey: str


class WebhookPartialFields(BaseModel):
    name: Annotated[Optional[str], Field(examples=['new-project-email'])] = None
    memo: Annotated[
        Optional[str], Field(examples=['Send an email when a project is added'])
    ] = None
    url: Annotated[
        Optional[AnyUrl], Field(examples=['https://example.com/webhook/123'])
    ] = None
    enabled: Optional[bool] = None
    eventTypes: Annotated[Optional[List[str]], Field(examples=[['add', 'update']])] = (
        None
    )
    isReadyColumn: Annotated[Optional[str], Field(examples=[None])] = None
    tableId: Annotated[Optional[str], Field(examples=['Projects'])] = None


class WebhookBatchStatus(BaseModel):
    size: Annotated[float, Field(examples=[1])]
    attempts: Annotated[float, Field(examples=[1])]
    errorMessage: Annotated[Optional[str], Field(examples=[None])] = None
    httpStatus: Annotated[Optional[float], Field(examples=[200])] = None
    status: Annotated[str, Field(examples=['success'])]


class WebhookId(BaseModel):
    id: Annotated[
        str,
        Field(
            description='Webhook identifier',
            examples=['xxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'],
        ),
    ]


class WebhookRequiredProperties(BaseModel):
    size: Annotated[float, Field(examples=[1])]


class WebhookProperties(RootModel[Any]):
    root: Any


class User(BaseModel):
    id: Annotated[int, Field(examples=[101])]
    name: Annotated[str, Field(examples=['Helga Hufflepuff'])]
    picture: Annotated[str, Field(examples=[None])]


class Access(Enum):
    owners = 'owners'
    editors = 'editors'
    viewers = 'viewers'


class Data(BaseModel):
    id: List[int]


class DataWithoutId(RootModel[Optional[Dict[str, List[Dict[str, Any]]]]]):
    root: Optional[Dict[str, List[Dict[str, Any]]]] = None


class Record(BaseModel):
    id: Annotated[float, Field(examples=[1])]
    fields: Annotated[
        Dict[str, Any],
        Field(
            description='A JSON object mapping column names to [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues).'
        ),
    ]


class RecordsList(BaseModel):
    records: List[Record]


class Record1(BaseModel):
    fields: Annotated[
        Dict[str, Any],
        Field(
            description='A JSON object mapping column names to [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues).'
        ),
    ]


class RecordsWithoutId(BaseModel):
    records: List[Record1]


class Record2(BaseModel):
    id: Annotated[float, Field(examples=[1])]


class RecordsWithoutFields(BaseModel):
    records: List[Record2]


class Record3(BaseModel):
    require: Annotated[
        Dict[str, Any],
        Field(
            description='keys are column identifiers, and values are [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues) we want to have in those columns (either by matching with an existing record, or creating a new record)\n'
        ),
    ]
    fields: Annotated[
        Optional[Dict[str, Any]],
        Field(
            description='keys are column identifiers, and values are [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues) to place in those columns (either overwriting values in an existing record, or in a new record)\n'
        ),
    ] = None


class RecordsWithRequire(BaseModel):
    records: List[Record3]


class Table(BaseModel):
    id: Annotated[str, Field(examples=['Table1'])]
    fields: Dict[str, Any]


class TablesList(BaseModel):
    tables: List[Table]


class Table1(BaseModel):
    id: Annotated[str, Field(examples=['Table1'])]


class TablesWithoutFields(BaseModel):
    tables: List[Table1]


class Column(BaseModel):
    id: Annotated[Optional[str], Field(examples=['ColumnName'])] = None
    fields: Optional[Dict[str, Any]] = None


class Table2(BaseModel):
    id: Annotated[Optional[str], Field(examples=['Table1'])] = None
    columns: List[Column]


class CreateTables(BaseModel):
    tables: List[Table2]


class Column4(BaseModel):
    id: Annotated[str, Field(examples=['ColumnName'])]


class ColumnsWithoutFields(BaseModel):
    columns: List[Column4]


class Type(Enum):
    Any = 'Any'
    Text = 'Text'
    Numeric = 'Numeric'
    Int = 'Int'
    Bool = 'Bool'
    Date = 'Date'
    DateTime__timezone_ = 'DateTime:<timezone>'
    Choice = 'Choice'
    ChoiceList = 'ChoiceList'
    Ref__tableId_ = 'Ref:<tableId>'
    RefList__tableId_ = 'RefList:<tableId>'
    Attachments = 'Attachments'


class Fields1(BaseModel):
    type: Annotated[
        Optional[Type],
        Field(
            description='Column type, by default Any. Ref, RefList and DateTime types requires a postfix, e.g. <code>DateTime:America/New_York</code>, <code>Ref:Users</code>'
        ),
    ] = None
    label: Annotated[Optional[str], Field(description='Column label.')] = None
    formula: Annotated[
        Optional[str],
        Field(
            description='A python formula, e.g.: <code>$A + Table1.lookupOne(B=$B)</code>'
        ),
    ] = None
    isFormula: Annotated[
        Optional[bool],
        Field(
            description='Use "true" to indicate that the column is a formula column. Use "false" for trigger formula column.'
        ),
    ] = None
    widgetOptions: Annotated[
        Optional[str],
        Field(
            description='A JSON object with widget options, e.g.: <code>{"choices": ["cat", "dog"], "alignment": "right"}</code>'
        ),
    ] = None
    untieColIdFromLabel: Annotated[
        Optional[bool],
        Field(
            description='Use "true" to indicate that the column label should not be used as the column identifier. Use "false" to use the label as the identifier.'
        ),
    ] = None
    recalcWhen: Annotated[
        Optional[int],
        Field(
            description="A number indicating when the column should be recalculated. <ol start='0'><li>On new records or when any field in recalcDeps changes, it's a 'data-cleaning'.</li><li>Never.</li><li>Calculate on new records and on manual updates to any data field.</li></ol>"
        ),
    ] = None
    visibleCol: Annotated[
        Optional[int],
        Field(
            description='For Ref and RefList columns, the colRef of a column to display'
        ),
    ] = None


class CreateFields(Fields1):
    recalcDeps: Annotated[
        Optional[str],
        Field(
            description='An encoded array of column identifiers (colRefs) that this column depends on. If any of these columns change, the column will be recalculated. E.g.: <code>[2, 3]</code>'
        ),
    ] = None


class GetFields(Fields1):
    recalcDeps: Annotated[
        Optional[List[int]],
        Field(
            description='An array of column identifiers (colRefs) that this column depends on, prefixed with "L" constant. If any of these columns change, the column will be recalculated. E.g.: <code>["L", 2, 3]</code>'
        ),
    ] = None
    colRef: Annotated[
        Optional[int], Field(description='Column reference, e.g.: <code>2</code>')
    ] = None


class RowIds(RootModel[List[int]]):
    root: Annotated[List[int], Field(examples=[[101, 102, 103]])]


class DocParameters(BaseModel):
    name: Annotated[Optional[str], Field(examples=['Competitive Analysis'])] = None
    isPinned: Annotated[Optional[bool], Field(examples=[False])] = None


class WorkspaceParameters(BaseModel):
    name: Annotated[Optional[str], Field(examples=['Retreat Docs'])] = None


class OrgParameters(BaseModel):
    name: Annotated[Optional[str], Field(examples=['ACME Unlimited'])] = None


class User1(BaseModel):
    id: Annotated[int, Field(examples=[1])]
    name: Annotated[str, Field(examples=['Andrea'])]
    email: Annotated[Optional[str], Field(examples=['andrea@getgrist.com'])] = None
    access: Optional[Access] = None


class OrgAccessRead(BaseModel):
    users: List[User1]


class UsersEnum(Enum):
    owners = 'owners'
    editors = 'editors'
    viewers = 'viewers'
    members = 'members'


class Users(RootModel[Optional[UsersEnum]]):
    root: Optional[UsersEnum] = None


class OrgAccessWrite(BaseModel):
    users: Annotated[
        Dict[str, Users],
        Field(examples=[{'foo@getgrist.com': 'owners', 'bar@getgrist.com': None}]),
    ]


class User2(BaseModel):
    id: Annotated[int, Field(examples=[1])]
    name: Annotated[str, Field(examples=['Andrea'])]
    email: Annotated[Optional[str], Field(examples=['andrea@getgrist.com'])] = None
    access: Optional[Access] = None
    parentAccess: Optional[Access] = None


class WorkspaceAccessRead(BaseModel):
    maxInheritedRole: Access
    users: List[User2]


class Users1Enum(Enum):
    owners = 'owners'
    editors = 'editors'
    viewers = 'viewers'
    members = 'members'


class Users1(RootModel[Optional[Users1Enum]]):
    root: Optional[Users1Enum] = None


class WorkspaceAccessWrite(BaseModel):
    maxInheritedRole: Optional[Access] = None
    users: Annotated[
        Optional[Dict[str, Users1]],
        Field(examples=[{'foo@getgrist.com': 'owners', 'bar@getgrist.com': None}]),
    ] = None


class DocAccessWrite(RootModel[WorkspaceAccessWrite]):
    root: WorkspaceAccessWrite


class DocAccessRead(RootModel[WorkspaceAccessRead]):
    root: WorkspaceAccessRead


class AttachmentUpload(BaseModel):
    upload: Optional[List[bytes]] = None


class AttachmentId(RootModel[float]):
    root: Annotated[float, Field(description='An integer ID')]


class AttachmentMetadata(BaseModel):
    fileName: Annotated[Optional[str], Field(examples=['logo.png'])] = None
    fileSize: Annotated[Optional[float], Field(examples=[12345])] = None
    timeUploaded: Annotated[
        Optional[str], Field(examples=['2020-02-13T12:17:19.000Z'])
    ] = None


class Record4(BaseModel):
    id: Annotated[float, Field(examples=[1])]
    fields: AttachmentMetadata


class AttachmentMetadataList(BaseModel):
    records: List[Record4]


class Record5(BaseModel):
    fields: Dict[str, Any]


class SqlResultSet(BaseModel):
    statement: Annotated[
        str,
        Field(
            description='A copy of the SQL statement.',
            examples=['select * from Pets ...'],
        ),
    ]
    records: Annotated[
        List[Record5],
        Field(
            examples=[
                [
                    {'fields': {'id': 1, 'pet': 'cat', 'popularity': 67}},
                    {'fields': {'id': 2, 'pet': 'dog', 'popularity': 95}},
                ]
            ]
        ),
    ]


class Format(Enum):
    csv = 'csv'


class Mediatype(Enum):
    text_csv = 'text/csv'


class Encoding(Enum):
    utf_8 = 'utf-8'


class CsvDialect(BaseModel):
    csvddfVersion: Annotated[
        Optional[float],
        Field(
            description='A number to indicate the schema version of CSV Dialect. Version 1.0 was named CSV Dialect Description Format and used different field names.',
            title='CSV Dialect schema version',
        ),
    ] = 1.2
    delimiter: Annotated[
        str,
        Field(
            description='A character sequence to use as the field separator.',
            examples=['{\n  "delimiter": ","\n}\n', '{\n  "delimiter": ";"\n}\n'],
            title='Delimiter',
        ),
    ]
    doubleQuote: Annotated[
        bool,
        Field(
            description='Specifies the handling of quotes inside fields.',
            examples=['{\n  "doubleQuote": true\n}\n'],
            title='Double Quote',
        ),
    ]
    lineTerminator: Annotated[
        Optional[str],
        Field(
            description='Specifies the character sequence that must be used to terminate rows.',
            examples=[
                '{\n  "lineTerminator": "\\r\\n"\n}\n',
                '{\n  "lineTerminator": "\\n"\n}\n',
            ],
            title='Line Terminator',
        ),
    ] = '\r\n'
    nullSequence: Annotated[
        Optional[str],
        Field(
            description='Specifies the null sequence, for example, `\\N`.',
            examples=['{\n  "nullSequence": "\\N"\n}\n'],
            title='Null Sequence',
        ),
    ] = None
    quoteChar: Annotated[
        Optional[str],
        Field(
            description='Specifies a one-character string to use as the quoting character.',
            examples=['{\n  "quoteChar": "\'"\n}\n'],
            title='Quote Character',
        ),
    ] = '"'
    escapeChar: Annotated[
        Optional[str],
        Field(
            description='Specifies a one-character string to use as the escape character.',
            examples=['{\n  "escapeChar": "\\\\"\n}\n'],
            title='Escape Character',
        ),
    ] = None
    skipInitialSpace: Annotated[
        Optional[bool],
        Field(
            description='Specifies the interpretation of whitespace immediately following a delimiter. If false, whitespace immediately after a delimiter should be treated as part of the subsequent field.',
            examples=['{\n  "skipInitialSpace": true\n}\n'],
            title='Skip Initial Space',
        ),
    ] = False
    header: Annotated[
        Optional[bool],
        Field(
            description='Specifies if the file includes a header row, always as the first row in the file.',
            examples=['{\n  "header": true\n}\n'],
            title='Header',
        ),
    ] = True
    commentChar: Annotated[
        Optional[str],
        Field(
            description='Specifies that any row beginning with this one-character string, without preceeding whitespace, causes the entire line to be ignored.',
            examples=['{\n  "commentChar": "#"\n}\n'],
            title='Comment Character',
        ),
    ] = None
    caseSensitiveHeader: Annotated[
        Optional[bool],
        Field(
            description='Specifies if the case of headers is meaningful.',
            examples=['{\n  "caseSensitiveHeader": true\n}\n'],
            title='Case Sensitive Header',
        ),
    ] = False


class Type1(Enum):
    string = 'string'


class Format1(Enum):
    default = 'default'
    email = 'email'
    uri = 'uri'
    binary = 'binary'
    uuid = 'uuid'


class Constraints(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    pattern: Annotated[
        Optional[str],
        Field(
            description='A regular expression pattern to test each value of the property against, where a truthy response indicates validity.'
        ),
    ] = None
    enum: Annotated[Optional[List[str]], Field(min_length=1)] = None
    minLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the minimum length of a value.'),
    ] = None
    maxLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the maximum length of a value.'),
    ] = None


class Fields2(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Optional[Type1],
        Field(description='The type keyword, which `MUST` be a value of `string`.'),
    ] = None
    format: Annotated[
        Optional[Format1],
        Field(
            description='The format keyword options for `string` are `default`, `email`, `uri`, `binary`, and `uuid`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints],
        Field(
            description='The following constraints are supported for `string` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type2(Enum):
    number = 'number'


class Format2(Enum):
    default = 'default'


class EnumModel(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum1(RootModel[List[float]]):
    root: Annotated[List[float], Field(min_length=1)]


class Constraints1(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[EnumModel, Enum1]] = None
    minimum: Optional[Union[str, float]] = None
    maximum: Optional[Union[str, float]] = None


class Fields3(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type2,
        Field(description='The type keyword, which `MUST` be a value of `number`.'),
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `number`: only `default` is allowed.'
        ),
    ] = 'default'
    bareNumber: Annotated[
        Optional[bool],
        Field(
            description='a boolean field with a default of `true`. If `true` the physical contents of this field must follow the formatting constraints already set out. If `false` the contents of this field may contain leading and/or trailing non-numeric characters (which implementors MUST therefore strip). The purpose of `bareNumber` is to allow publishers to publish numeric data that contains trailing characters such as percentages e.g. `95%` or leading characters such as currencies e.g. `€95` or `EUR 95`. Note that it is entirely up to implementors what, if anything, they do with stripped text.',
            title='bareNumber',
        ),
    ] = True
    decimalChar: Annotated[
        Optional[str],
        Field(
            description='A string whose value is used to represent a decimal point within the number. The default value is `.`.'
        ),
    ] = None
    groupChar: Annotated[
        Optional[str],
        Field(
            description="A string whose value is used to group digits within the number. The default value is `null`. A common value is `,` e.g. '100,000'."
        ),
    ] = None
    constraints: Annotated[
        Optional[Constraints1],
        Field(
            description='The following constraints are supported for `number` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type3(Enum):
    integer = 'integer'


class Enum2(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum3(RootModel[List[int]]):
    root: Annotated[List[int], Field(min_length=1)]


class Constraints2(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum2, Enum3]] = None
    minimum: Optional[Union[str, int]] = None
    maximum: Optional[Union[str, int]] = None


class Fields4(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type3,
        Field(description='The type keyword, which `MUST` be a value of `integer`.'),
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `integer`: only `default` is allowed.'
        ),
    ] = 'default'
    bareNumber: Annotated[
        Optional[bool],
        Field(
            description='a boolean field with a default of `true`. If `true` the physical contents of this field must follow the formatting constraints already set out. If `false` the contents of this field may contain leading and/or trailing non-numeric characters (which implementors MUST therefore strip). The purpose of `bareNumber` is to allow publishers to publish numeric data that contains trailing characters such as percentages e.g. `95%` or leading characters such as currencies e.g. `€95` or `EUR 95`. Note that it is entirely up to implementors what, if anything, they do with stripped text.',
            title='bareNumber',
        ),
    ] = True
    constraints: Annotated[
        Optional[Constraints2],
        Field(
            description='The following constraints are supported for `integer` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type4(Enum):
    date = 'date'


class Constraints3(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Annotated[Optional[List[str]], Field(min_length=1)] = None
    minimum: Optional[str] = None
    maximum: Optional[str] = None


class Fields5(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type4, Field(description='The type keyword, which `MUST` be a value of `date`.')
    ]
    format: Annotated[
        Optional[Any],
        Field(
            description='The format keyword options for `date` are `default`, `any`, and `{PATTERN}`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints3],
        Field(
            description='The following constraints are supported for `date` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type5(Enum):
    time = 'time'


class Fields6(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type5, Field(description='The type keyword, which `MUST` be a value of `time`.')
    ]
    format: Annotated[
        Optional[Any],
        Field(
            description='The format keyword options for `time` are `default`, `any`, and `{PATTERN}`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints3],
        Field(
            description='The following constraints are supported for `time` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type6(Enum):
    datetime = 'datetime'


class Fields7(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type6,
        Field(description='The type keyword, which `MUST` be a value of `datetime`.'),
    ]
    format: Annotated[
        Optional[Any],
        Field(
            description='The format keyword options for `datetime` are `default`, `any`, and `{PATTERN}`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints3],
        Field(
            description='The following constraints are supported for `datetime` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type7(Enum):
    year = 'year'


class Enum4(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum5(RootModel[List[int]]):
    root: Annotated[List[int], Field(min_length=1)]


class Constraints6(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum4, Enum5]] = None
    minimum: Optional[Union[str, int]] = None
    maximum: Optional[Union[str, int]] = None


class Fields8(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type7, Field(description='The type keyword, which `MUST` be a value of `year`.')
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `year`: only `default` is allowed.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints6],
        Field(
            description='The following constraints are supported for `year` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type8(Enum):
    yearmonth = 'yearmonth'


class Constraints7(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Annotated[Optional[List[str]], Field(min_length=1)] = None
    minimum: Optional[str] = None
    maximum: Optional[str] = None


class Fields9(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type8,
        Field(description='The type keyword, which `MUST` be a value of `yearmonth`.'),
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `yearmonth`: only `default` is allowed.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints7],
        Field(
            description='The following constraints are supported for `yearmonth` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type9(Enum):
    boolean = 'boolean'


class Constraints8(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    enum: Annotated[Optional[List[bool]], Field(min_length=1)] = None


class Fields10(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type9,
        Field(description='The type keyword, which `MUST` be a value of `boolean`.'),
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `boolean`: only `default` is allowed.'
        ),
    ] = 'default'
    trueValues: Annotated[Optional[List[str]], Field(min_length=1)] = [
        'true',
        'True',
        'TRUE',
        '1',
    ]
    falseValues: Annotated[Optional[List[str]], Field(min_length=1)] = [
        'false',
        'False',
        'FALSE',
        '0',
    ]
    constraints: Annotated[
        Optional[Constraints8],
        Field(
            description='The following constraints are supported for `boolean` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type10(Enum):
    object = 'object'


class Enum6(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum7(RootModel[List[Dict[str, Any]]]):
    root: Annotated[List[Dict[str, Any]], Field(min_length=1)]


class Constraints9(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum6, Enum7]] = None
    minLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the minimum length of a value.'),
    ] = None
    maxLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the maximum length of a value.'),
    ] = None


class Fields11(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type10,
        Field(description='The type keyword, which `MUST` be a value of `object`.'),
    ]
    format: Annotated[
        Optional[Format2],
        Field(
            description='There are no format keyword options for `object`: only `default` is allowed.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints9],
        Field(
            description='The following constraints apply for `object` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type11(Enum):
    geopoint = 'geopoint'


class Format8(Enum):
    default = 'default'
    array = 'array'
    object = 'object'


class Enum8(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum9(RootModel[List[List]]):
    root: Annotated[List[List], Field(min_length=1)]


class Enum10(RootModel[List[Dict[str, Any]]]):
    root: Annotated[List[Dict[str, Any]], Field(min_length=1)]


class Constraints10(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum8, Enum9, Enum10]] = None


class Fields12(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type11,
        Field(description='The type keyword, which `MUST` be a value of `geopoint`.'),
    ]
    format: Annotated[
        Optional[Format8],
        Field(
            description='The format keyword options for `geopoint` are `default`,`array`, and `object`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints10],
        Field(
            description='The following constraints are supported for `geopoint` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type12(Enum):
    geojson = 'geojson'


class Format9(Enum):
    default = 'default'
    topojson = 'topojson'


class Enum11(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum12(RootModel[List[Dict[str, Any]]]):
    root: Annotated[List[Dict[str, Any]], Field(min_length=1)]


class Constraints11(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum11, Enum12]] = None
    minLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the minimum length of a value.'),
    ] = None
    maxLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the maximum length of a value.'),
    ] = None


class Fields13(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type12,
        Field(description='The type keyword, which `MUST` be a value of `geojson`.'),
    ]
    format: Annotated[
        Optional[Format9],
        Field(
            description='The format keyword options for `geojson` are `default` and `topojson`.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints11],
        Field(
            description='The following constraints are supported for `geojson` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type13(Enum):
    array = 'array'


class Format10(Enum):
    default = 'default'


class Enum13(RootModel[List[str]]):
    root: Annotated[List[str], Field(min_length=1)]


class Enum14(RootModel[List[List]]):
    root: Annotated[List[List], Field(min_length=1)]


class Constraints12(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Optional[Union[Enum13, Enum14]] = None
    minLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the minimum length of a value.'),
    ] = None
    maxLength: Annotated[
        Optional[int],
        Field(description='An integer that specifies the maximum length of a value.'),
    ] = None


class Fields14(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type13,
        Field(description='The type keyword, which `MUST` be a value of `array`.'),
    ]
    format: Annotated[
        Optional[Format10],
        Field(
            description='There are no format keyword options for `array`: only `default` is allowed.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints12],
        Field(
            description='The following constraints apply for `array` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type14(Enum):
    duration = 'duration'


class Constraints13(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Annotated[Optional[List[str]], Field(min_length=1)] = None
    minimum: Optional[str] = None
    maximum: Optional[str] = None


class Fields15(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type14,
        Field(description='The type keyword, which `MUST` be a value of `duration`.'),
    ]
    format: Annotated[
        Optional[Format10],
        Field(
            description='There are no format keyword options for `duration`: only `default` is allowed.'
        ),
    ] = 'default'
    constraints: Annotated[
        Optional[Constraints13],
        Field(
            description='The following constraints are supported for `duration` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class Type15(Enum):
    any = 'any'


class Constraints14(BaseModel):
    required: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether a property must have a value for each instance.'
        ),
    ] = None
    unique: Annotated[
        Optional[bool],
        Field(description='When `true`, each value for the property `MUST` be unique.'),
    ] = None
    enum: Annotated[Optional[List], Field(min_length=1)] = None


class Fields16(BaseModel):
    name: Annotated[str, Field(description='A name for this field.', title='Name')]
    title: Annotated[
        Optional[str],
        Field(
            description='A human-readable title.',
            examples=['{\n  "title": "My Package Title"\n}\n'],
            title='Title',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A text description. Markdown is encouraged.',
            examples=[
                '{\n  "description": "# My Package description\\nAll about my package."\n}\n'
            ],
            title='Description',
        ),
    ] = None
    example: Annotated[
        Optional[str],
        Field(
            description='An example value for the field.',
            examples=[
                '{\n  "example": "Put here an example value for your field"\n}\n'
            ],
            title='Example',
        ),
    ] = None
    type: Annotated[
        Type15, Field(description='The type keyword, which `MUST` be a value of `any`.')
    ]
    constraints: Annotated[
        Optional[Constraints14],
        Field(
            description='The following constraints apply to `any` fields.',
            title='Constraints',
        ),
    ] = None
    rdfType: Annotated[
        Optional[str], Field(description='The RDF type for this field.')
    ] = None


class PrimaryKey(RootModel[List[str]]):
    root: Annotated[
        List[str],
        Field(
            description='A primary key is a field name or an array of field names, whose values `MUST` uniquely identify each row in the table.',
            examples=[
                '{\n  "primaryKey": [\n    "name"\n  ]\n}\n',
                '{\n  "primaryKey": [\n    "first_name",\n    "last_name"\n  ]\n}\n',
            ],
            min_length=1,
        ),
    ]


class FieldModel(RootModel[str]):
    root: Annotated[
        str, Field(description='Fields that make up the primary key.', min_length=1)
    ]


class Reference(BaseModel):
    resource: str
    fields: Annotated[List[str], Field(min_length=1)]


class ForeignKeys(BaseModel):
    fields: List[FieldModel]
    reference: Reference


class Reference1(BaseModel):
    resource: str
    fields: str


class ForeignKeys1(BaseModel):
    fields: Annotated[str, Field(description='Fields that make up the primary key.')]
    reference: Reference1


class TableSchema(BaseModel):
    fields: Annotated[
        List[
            Union[
                Fields2,
                Fields3,
                Fields4,
                Fields5,
                Fields6,
                Fields7,
                Fields8,
                Fields9,
                Fields10,
                Fields11,
                Fields12,
                Fields13,
                Fields14,
                Fields15,
                Fields16,
            ]
        ],
        Field(
            description='An `array` of Table Schema Field objects.',
            examples=[
                '{\n  "fields": [\n    {\n      "name": "my-field-name"\n    }\n  ]\n}\n',
                '{\n  "fields": [\n    {\n      "name": "my-field-name",\n      "type": "number"\n    },\n    {\n      "name": "my-field-name-2",\n      "type": "string",\n      "format": "email"\n    }\n  ]\n}\n',
            ],
            min_length=1,
        ),
    ]
    primaryKey: Annotated[
        Optional[Union[PrimaryKey, str]],
        Field(
            description='A primary key is a field name or an array of field names, whose values `MUST` uniquely identify each row in the table.',
            examples=[
                '{\n  "primaryKey": [\n    "name"\n  ]\n}\n',
                '{\n  "primaryKey": [\n    "first_name",\n    "last_name"\n  ]\n}\n',
            ],
        ),
    ] = None
    foreignKeys: Annotated[
        Optional[List[Union[ForeignKeys, ForeignKeys1]]],
        Field(
            examples=[
                '{\n  "foreignKeys": [\n    {\n      "fields": "state",\n      "reference": {\n        "resource": "the-resource",\n        "fields": "state_id"\n      }\n    }\n  ]\n}\n',
                '{\n  "foreignKeys": [\n    {\n      "fields": "state",\n      "reference": {\n        "resource": "",\n        "fields": "id"\n      }\n    }\n  ]\n}\n',
            ],
            min_length=1,
        ),
    ] = None
    missingValues: Annotated[
        Optional[List[str]],
        Field(
            description="Values that when encountered in the source, should be considered as `null`, 'not present', or 'blank' values.",
            examples=[
                '{\n  "missingValues": [\n    "-",\n    "NaN",\n    ""\n  ]\n}\n',
                '{\n  "missingValues": []\n}\n',
            ],
        ),
    ] = ['']


class Org(BaseModel):
    id: Annotated[int, Field(examples=[42])]
    name: Annotated[str, Field(examples=['Grist Labs'])]
    domain: Annotated[str, Field(examples=['gristlabs'])]
    owner: User
    access: Access
    createdAt: Annotated[str, Field(examples=['2019-09-13T15:42:35.000Z'])]
    updatedAt: Annotated[str, Field(examples=['2019-09-13T15:42:35.000Z'])]


class Orgs(RootModel[List[Org]]):
    root: List[Org]


class WebhookFields(WebhookPartialFields, WebhookRequiredFields):
    pass


class WebhookUsage(BaseModel):
    numWaiting: int
    status: Annotated[str, Field(examples=['idle'])]
    updatedTime: Annotated[Optional[float], Field(examples=[1685637500424])] = None
    lastSuccessTime: Annotated[Optional[float], Field(examples=[1685637500424])] = None
    lastFailureTime: Annotated[Optional[float], Field(examples=[1685637500424])] = None
    lastErrorMessage: Annotated[Optional[str], Field(examples=[None])] = None
    lastHttpStatus: Annotated[Optional[float], Field(examples=[200])] = None
    lastEventBatch: Optional[WebhookBatchStatus] = None


class Workspace(BaseModel):
    id: Annotated[int, Field(examples=[97])]
    name: Annotated[str, Field(examples=['Secret Plans'])]
    access: Access


class Doc(BaseModel):
    id: Annotated[str, Field(examples=[145])]
    name: Annotated[str, Field(examples=['Project Lollipop'])]
    access: Access
    isPinned: Annotated[bool, Field(examples=[True])]
    urlId: Annotated[str, Field(examples=[None])]


class WorkspaceWithDocs(Workspace):
    docs: List[Doc]


class WorkspaceWithDocsAndDomain(WorkspaceWithDocs):
    orgDomain: Annotated[Optional[str], Field(examples=['gristlabs'])] = None


class WorkspaceWithOrg(Workspace):
    org: Org


class WorkspaceWithDocsAndOrg(WorkspaceWithDocs, WorkspaceWithOrg):
    pass


class DocWithWorkspace(Doc):
    workspace: WorkspaceWithOrg


class Column1(BaseModel):
    id: Annotated[Optional[str], Field(examples=['ColumnName'])] = None
    fields: Optional[GetFields] = None


class ColumnsList(BaseModel):
    columns: Optional[List[Column1]] = None


class Column2(BaseModel):
    id: Annotated[Optional[str], Field(description='Column identifier')] = None
    fields: Optional[CreateFields] = None


class CreateColumns(BaseModel):
    columns: List[Column2]


class Fields(CreateFields):
    colId: Annotated[
        Optional[str],
        Field(description='Set it to the new column ID when you want to change it.'),
    ] = None


class Column3(BaseModel):
    id: Annotated[str, Field(description='Column identifier')]
    fields: Fields


class UpdateColumns(BaseModel):
    columns: List[Column3]


class TableSchemaResult(BaseModel):
    name: Annotated[str, Field(description='The ID (technical name) of the table')]
    title: Annotated[str, Field(description='The human readable name of the table')]
    path: Annotated[
        Optional[str],
        Field(
            description='The URL to download the CSV',
            examples=[
                'https://getgrist.com/o/docs/api/docs/ID/download/csv?tableId=Table1&....'
            ],
        ),
    ] = None
    format: Optional[Format] = None
    mediatype: Optional[Mediatype] = None
    encoding: Optional[Encoding] = None
    dialect: Optional[CsvDialect] = None
    schema_: Annotated[TableSchema, Field(alias='schema')]


class Webhook(BaseModel):
    id: Annotated[
        Optional[UUID], Field(examples=['xxxxxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx'])
    ] = None
    fields: Optional[WebhookFields] = None
    usage: Optional[WebhookUsage] = None


class Webhooks(RootModel[List[Webhook]]):
    root: List[Webhook]
